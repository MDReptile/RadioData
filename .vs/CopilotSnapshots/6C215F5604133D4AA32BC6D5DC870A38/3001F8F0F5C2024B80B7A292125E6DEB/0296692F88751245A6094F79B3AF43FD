using NAudio.Wave;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace RadioDataApp.Services
{
    public class AudioService : IDisposable
    {
        private WaveInEvent? _waveIn;
        private WaveOutEvent? _waveOut;
        private BufferedWaveProvider? _bufferedWaveProvider;

        public event EventHandler<byte[]>? AudioDataReceived;
        public event EventHandler? TransmissionCompleted;

        public bool IsInputLoopbackMode { get; set; } = false;
        public bool IsOutputLoopbackMode { get; set; } = false;

        public static List<WaveInCapabilities> GetInputDevices()
        {
            var devices = new List<WaveInCapabilities>();
            for (int i = 0; i < WaveIn.DeviceCount; i++)
            {
                devices.Add(WaveIn.GetCapabilities(i));
            }
            return devices;
        }

        public static List<WaveOutCapabilities> GetOutputDevices()
        {
            var devices = new List<WaveOutCapabilities>();
            for (int i = 0; i < WaveOut.DeviceCount; i++)
            {
                devices.Add(WaveOut.GetCapabilities(i));
            }
            return devices;
        }

        public void StartListening(int deviceNumber)
        {
            if (IsInputLoopbackMode)
            {
                Console.WriteLine("[AudioService] Input loopback mode - skipping StartListening");
                return;
            }

            StopListening();

            _waveIn = new WaveInEvent
            {
                DeviceNumber = deviceNumber,
                WaveFormat = new WaveFormat(44100, 1)
            };

            _waveIn.DataAvailable += OnDataAvailable;
            _waveIn.StartRecording();
        }

        public void StopListening()
        {
            if (_waveIn != null)
            {
                _waveIn.StopRecording();
                _waveIn.DataAvailable -= OnDataAvailable;
                _waveIn.Dispose();
                _waveIn = null;
            }
        }

        private void OnDataAvailable(object? sender, WaveInEventArgs e)
        {
            byte[] buffer = new byte[e.BytesRecorded];
            Array.Copy(e.Buffer, buffer, e.BytesRecorded);
            AudioDataReceived?.Invoke(this, buffer);
        }

        // --- Transmission Logic ---

        public void InitializeTransmission(int deviceNumber)
        {
            if (IsOutputLoopbackMode)
            {
                Console.WriteLine("[AudioService] Output loopback mode - InitializeTransmission (no-op)");
                return;
            }

            Console.WriteLine($"[AudioService] InitializeTransmission called with device index: {deviceNumber}");

            var outputs = GetOutputDevices();
            if (deviceNumber >= 0 && deviceNumber < outputs.Count)
            {
                Console.WriteLine($"[AudioService] Opening output device: {outputs[deviceNumber].ProductName}");
            }
            else
            {
                Console.WriteLine($"[AudioService] ERROR: Device index {deviceNumber} out of range (0-{outputs.Count - 1})");
            }

            if (_waveOut == null || _waveOut.PlaybackState != PlaybackState.Playing)
            {
                StopTransmission();
            }

            _waveOut = new WaveOutEvent
            {
                DeviceNumber = deviceNumber
            };

            _bufferedWaveProvider = new BufferedWaveProvider(new WaveFormat(44100, 1))
            {
                BufferDuration = TimeSpan.FromMinutes(10),
                DiscardOnBufferOverflow = false
            };

            _waveOut.Init(_bufferedWaveProvider);
            _waveOut.Play();
            Console.WriteLine($"[AudioService] Started playback on device {deviceNumber}");
        }

        public void QueueAudio(byte[] audioData)
        {
            if (IsOutputLoopbackMode)
            {
                Console.WriteLine($"[AudioService] Output loopback mode - queuing {audioData.Length} bytes to demodulator");
                AudioDataReceived?.Invoke(this, audioData);
                return;
            }

            _bufferedWaveProvider?.AddSamples(audioData, 0, audioData.Length);
        }

        public TimeSpan GetBufferedDuration()
        {
            return _bufferedWaveProvider?.BufferedDuration ?? TimeSpan.Zero;
        }

        public void StopTransmission()
        {
            if (IsOutputLoopbackMode)
            {
                // In loopback mode, just fire the completion event
                Console.WriteLine("[AudioService] Output Loopback mode - StopTransmission");
                TransmissionCompleted?.Invoke(this, EventArgs.Empty);
                return;
            }

            if (_waveOut != null)
            {
                _waveOut.Stop();
                _waveOut.Dispose();
                _waveOut = null;
            }
            _bufferedWaveProvider = null;
            TransmissionCompleted?.Invoke(this, EventArgs.Empty);
        }

        // Legacy method for single-shot transmission (kept for compatibility)
        public void StartTransmitting(int deviceNumber, byte[] audioData)
        {
            if (IsOutputLoopbackMode)
            {
                // In loopback mode, immediately feed audio to demodulator
                Console.WriteLine($"[AudioService] Output Loopback mode - feeding {audioData.Length} bytes to demodulator");
                AudioDataReceived?.Invoke(this, audioData);

                // Simulate transmission completion after a short delay
                Task.Run(async () =>
                {
                    await Task.Delay(100);
                    TransmissionCompleted?.Invoke(this, EventArgs.Empty);
                });
                return;
            }

            InitializeTransmission(deviceNumber);
            QueueAudio(audioData);

            // Wait for it to finish in a background thread so we don't block but can fire event
            new Thread(() =>
            {
                while (_bufferedWaveProvider != null && _bufferedWaveProvider.BufferedDuration.TotalMilliseconds > 0)
                {
                    Thread.Sleep(100);
                }
                StopTransmission();
            }).Start();
        }

        public void Dispose()
        {
            StopListening();
            StopTransmission();
            GC.SuppressFinalize(this);
        }
    }
}
